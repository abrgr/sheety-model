{"version":3,"sources":["../../src/lib/cell-format.js"],"names":["types","Object","freeze","TEXT","NUMBER","PERCENT","CURRENCY","DATE","TIME","DATE_TIME","SCIENTIFIC","isNumericType","type","probablyToNum","val","exec","toStr","toJSValue","format","toFormatableValue","fromUserEnteredNum","maybeNum","match","NaN","n","lastComma","lastIndexOf","lastDecimal","parseFloat","replace","parseInt","userEnteredValueToSheetValue","diff","indexOf","CellFormatRecord","pattern","coercer","bind","CellFormat","params","valueOf","get","value","matchingTypes","userEnteredValue","Types"],"mappings":"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","file":"cell-format.js","sourcesContent":["import { Map, Record } from 'immutable';\nimport ssf from 'ssf';\nimport moment from 'moment';\nimport coerce from './coerce';\n\nconst types = Object.freeze({\n  TEXT: 'TEXT',\n  NUMBER: 'NUMBER',\n  PERCENT: 'PERCENT',\n  CURRENCY: 'CURRENCY',\n  DATE: 'DATE',\n  TIME: 'TIME',\n  DATE_TIME: 'DATE_TIME',\n  SCIENTIFIC: 'SCIENTIFIC'\n});\n\nfunction isNumericType(type) {\n  return type !== types.TEXT;\n}\n\nconst probablyToNum = (val) => {\n  if ( typeof val === 'number' ) {\n    return val;\n  }\n\n  if ( /^(-+)?\\d*[.]?\\d*$/.exec('' + val) ) {\n    return +val;\n  }\n\n  // probably mis-categorized as a number\n  return val;\n};\nconst toStr = (val) => !!val ? ('' + val) : '';\n\nconst toJSValue = Object.freeze({\n  TEXT: toStr,\n  NUMBER: probablyToNum,\n  PERCENT: probablyToNum,\n  CURRENCY: probablyToNum,\n  DATE: (val) => moment(ssf.format('yyyy-mm-dd', val), 'YYYY-MM-DD'),\n  TIME: (val) => moment(ssf.format('yyyy-mm-dd hh:mm:ss', val), 'YYYY-MM-DD HH:mm:ss'), // TODO: is this right?\n  DATE_TIME: (val) => moment(ssf.format('yyyy-mm-dd hh:mm:ss', val), 'YYYY-MM-DD HH:mm:ss'),\n  SCIENTIFIC: probablyToNum\n});\n\nconst toFormatableValue = Object.freeze({\n  TEXT: toStr,\n  NUMBER: probablyToNum,\n  PERCENT: probablyToNum,\n  CURRENCY: probablyToNum,\n  DATE: probablyToNum,\n  TIME: probablyToNum,\n  DATE_TIME: probablyToNum,\n  SCIENTIFIC: probablyToNum\n});\n\nconst fromUserEnteredNum = (maybeNum) => {\n  if ( typeof maybeNum === 'number' ) {\n    return maybeNum;\n  }\n\n  const match = /[-]?\\d[\\d,.]*|[,.][\\d,.]+/.exec(maybeNum);\n  if ( !match ) {\n    return NaN;\n  }\n\n  const n = '' + maybeNum;\n\n  // TODO: we should actually figure out what the locale uses for a decimal separator\n  // now, try to guess at a locale to deal with decimals\n  const lastComma = n.lastIndexOf(',');\n  const lastDecimal = n.lastIndexOf('.');\n\n  if ( lastComma > lastDecimal ) {\n    // we're either European with a decimal or US without a decimal\n    if ( lastDecimal >= 0 ) {\n      // if we have both, we are much more likely European with a decimal\n      return parseFloat(n.replace('.', '').replace(',', '.'));\n    }\n\n    // otherwise, we assume we're US\n    return parseInt(n.replace(',', ''), 10);\n  } else if ( lastDecimal > lastComma ) {\n    // we're either US with a decimal or European without a decimal\n    // just assume we're US for now\n    return parseFloat(n.replace(',', ''));\n  }\n\n  // we have no comma or decimal\n  return parseInt(n, 10);\n};\n\nconst userEnteredValueToSheetValue = Object.freeze({\n  TEXT: (val) => '' + val,\n  NUMBER: fromUserEnteredNum,\n  PERCENT: (val) => fromUserEnteredNum(val) / 100,\n  CURRENCY: fromUserEnteredNum,\n  DATE: (val) => moment(val).diff(moment('1899-12-30'), 'days'),\n  TIME: (val) => moment(val), // TODO: is this right?\n  DATE_TIME: (val) => moment(val).diff(moment('1899-12-30')) / 86400000,\n  SCIENTIFIC: (val) => {\n    if ( typeof val === 'string' && val.indexOf('e') > 0 ) {\n      return parseFloat(val);\n    }\n\n    return fromUserEnteredNum(val);\n  }\n});\n\nconst CellFormatRecord = Record({\n  type: types.TEXT,\n  pattern: ''\n});\n\nconst coercer = coerce.bind(null, new Map({\n  type: (type) => !!type && !!types[type] ? type : types.TEXT,\n  pattern: (pattern) => !!pattern ? pattern : ''\n}));\n\nexport default class CellFormat extends CellFormatRecord {\n  constructor(params) {\n    super(coercer(params));\n  }\n\n  format(val) {\n    const valueOf = toFormatableValue[this.get('type')];\n    const value = !!valueOf ? valueOf(val) : val;\n\n    const matchingTypes = isNumericType(this.get('type'))\n                        ? typeof value === 'number'\n                        : typeof value === 'string';\n\n    return matchingTypes\n         ? ssf.format(this.get('pattern'), value)\n         : val;\n  }\n\n  toJSValue(val) {\n    const valueOf = toJSValue[this.get('type')];\n    return valueOf ? valueOf(val) : val;\n  }\n\n  fromUserEnteredValue(userEnteredValue) {\n    const valueOf = userEnteredValueToSheetValue[this.get('type')];\n    return valueOf\n         ? valueOf(userEnteredValue)\n         : userEnteredValue;\n  }\n}\n\nCellFormat.Types = types;\n"]}